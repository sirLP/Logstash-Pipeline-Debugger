# 10-unbound.pfelk
################################################################################
# Version: 24.09                                                               #
# Required: False                                                              #
# Description: Parses Unbound DNS resolver logs including queries, responses,  #
#              and DNSSEC validation messages                                  #
################################################################################
#
filter {
  ### unbound ###
  if [type] == "unbound" or [log][syslog][appname] =~ /^unbound/ {
    if ![filter_message] and [message] {
      mutate {
        copy => { "message" => "filter_message" }
      }
    }

    if [filter_message] =~ /^<\d+>\d+\s+/ {
      grok {
        match => {
          "filter_message" => "<%{INT}>%{INT}\s+%{TIMESTAMP_ISO8601}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{GREEDYDATA:filter_message}"
        }
        overwrite => [ "filter_message" ]
        tag_on_failure => []
      }
    }

    if [filter_message] =~ /^\d{4}-\d{2}-\d{2}T/ {
      grok {
        match => {
          "filter_message" => [
            "%{TIMESTAMP_ISO8601}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+-\s+-\s+%{NOTSPACE}\s+-\s+-\s+%{GREEDYDATA:filter_message}",
            "%{TIMESTAMP_ISO8601}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+-\s+-\s+%{GREEDYDATA:filter_message}"
          ]
        }
        overwrite => [ "filter_message" ]
        tag_on_failure => []
      }
    }

    if [filter_message] !~ /^\[\d+:\d+\]\s+/ {
      grok {
        match => {
          "filter_message" => ".*(?<unbound_payload>\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\]\s+%{LOGLEVEL:[log][level]}:\s+%{GREEDYDATA})"
        }
        tag_on_failure => []
      }
      if [unbound_payload] {
        mutate {
          replace => { "filter_message" => "%{unbound_payload}" }
          remove_field => [ "unbound_payload" ]
        }
      }
    }

    mutate {
      add_tag => "unbound"
      replace => {
        "[log][syslog][appname]" => "unbound"
        "[event][dataset]" => "pfelk.unbound"
        "[data_stream][dataset]" => "pfelk.unbound"
        "[data_stream][namespace]" => "unbound"
      }
    }
    
    # Parse DNSSEC validation messages
    if [filter_message] =~ /Verified that/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: Verified that %{WORD:[dnssec][response_type]} response is %{WORD:[dnssec][validation_state]}" ]
      }
      mutate {
        add_field => { "[dnssec][message_type]" => "validation" }
        add_tag => "dnssec_validation"
      }
    }
    else if [filter_message] =~ /NSEC3?s? / {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: %{WORD:[dnssec][proof_type]} for %{DATA:[dnssec][target]} (?<[dnssec][result]>proved .+)$" ]
      }
      mutate {
        add_field => { "[dnssec][message_type]" => "proof" }
        add_tag => "dnssec_proof"
      }
    }
    else if [filter_message] =~ /validation failure/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: validation failure %{NOTSPACE:[dns][question][name]}" ]
      }
      mutate {
        add_field => { 
          "[dnssec][message_type]" => "validation_failure"
          "[event][outcome]" => "failure"
        }
        add_tag => "dnssec_failure"
      }
    }
    else if [filter_message] =~ /prime trust anchor/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: %{DATA:[dnssec][action]}: %{GREEDYDATA:[dnssec][details]}" ]
      }
      mutate {
        add_field => { "[dnssec][message_type]" => "trust_anchor" }
        add_tag => "dnssec_anchor"
      }
    }
    else if [filter_message] =~ /sendto failed/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: sendto failed: %{GREEDYDATA:[network][error]}" ]
      }
      mutate {
        add_field => { "[event][outcome]" => "failure" }
        add_tag => "network_error"
      }
    }
    # Parse actual DNS queries/responses
    else {
      # First, check for response status messages (e.g., "query response was nodata ANSWER")
      if [filter_message] =~ /query response was/ {
        grok {
          match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: query response was %{WORD:[dns][response_status]} %{WORD:[dns][response_type]}" ]
        }
        mutate {
          add_field => { "[dns][message_type]" => "response_status" }
        }
      }
      # Otherwise, parse as normal DNS query/response
      else {
        grok {
          patterns_dir => [ "/etc/pfelk/patterns" ]
          match => [ "filter_message", "%{UNBOUND}" ]
        }
        if "_grokparsefailure" in [tags] {
          mutate { remove_tag => [ "_grokparsefailure" ] }
          grok {
            patterns_dir => [ "/etc/pfelk/patterns" ]
            match => [ "filter_message", "%{UNBOUND_RESOLVING}" ]
          }
        }
        ### unbound ECS => Built-in SIEM ###
        grok {
          match => [ "[dns][question][name]", "(\.)?(?<[dns][question][registered_domain]>[^.]+\.[^.]+)\.?$" ] 
          add_tag => "unbound-registered_domain"
        }
        if "unbound-registered_domain" not in [tags] {
          grok { 
            match => [ "[dns][question][name]", "(?<[dns][question][registered_domain]>[^.]+\.[^.]+)\.?$" ] 
          }
        }
        grok {
          match => [ "[dns][question][name]", "(\.)?(?<[dns][question][top_level_domain]>[^.]+)\.?$" ]
        }

        mutate {
          remove_tag => "unbound-registered_domain"
        }
      
      # Ensure dataset is set even if earlier steps fail
      if "unbound" in [tags] {
        mutate { replace => { "[event][dataset]" => "pfelk.unbound" "[data_stream][dataset]" => "pfelk.unbound" } }
      }
      }
    }
  }
}
