# 10-unbound.pfelk
################################################################################
# Version: 24.09                                                               #
# Required: False                                                              #
# Description: Parses Unbound DNS resolver logs including queries, responses,  #
#              and DNSSEC validation messages                                  #
################################################################################
#
filter {
  ### unbound ###
  if [type] == "unbound" or [log][syslog][appname] =~ /^unbound/ {
    if ![filter_message] and [message] {
      mutate {
        copy => { "message" => "filter_message" }
      }
    }

    if [filter_message] =~ /^<\d+>\d+\s+/ {
      grok {
        match => {
          "filter_message" => "<%{INT}>%{INT}\s+%{TIMESTAMP_ISO8601}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{GREEDYDATA:filter_message}"
        }
        overwrite => [ "filter_message" ]
        tag_on_failure => ["grok_fail_35_unbound_strip_inner_rfc5424"]
      }
    }

    if [filter_message] =~ /^\d{4}-\d{2}-\d{2}T/ {
      grok {
        match => {
          "filter_message" => [
            "%{TIMESTAMP_ISO8601}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+-\s+-\s+%{NOTSPACE}\s+-\s+-\s+%{GREEDYDATA:filter_message}",
            "%{TIMESTAMP_ISO8601}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+%{NOTSPACE}\s+-\s+-\s+%{GREEDYDATA:filter_message}"
          ]
        }
        overwrite => [ "filter_message" ]
        tag_on_failure => ["grok_fail_35_unbound_strip_inner_timestamp"]
      }
    }

    # Canonicalize to unbound payload regardless of any remaining prefix
    # Example result: [97869:0] info: 192.168.178.58 telemetry.elastic.co. A IN NOERROR ...
    grok {
      match => {
        "filter_message" => ".*(\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\]\s+%{LOGLEVEL:[log][level]}:\s+%{GREEDYDATA:unbound_payload})"
      }
      tag_on_failure => ["grok_fail_35_unbound_payload_extract"]
    }
    if [unbound_payload] {
      mutate {
        replace => { "filter_message" => "[%{[process][pgid]}:%{[process][thread][id]}] %{[log][level]}: %{unbound_payload}" }
        remove_field => [ "unbound_payload" ]
      }
    }

    mutate {
      add_tag => "unbound"
      replace => {
        "[log][syslog][appname]" => "unbound"
        "[event][dataset]" => "pfelk.unbound"
        "[data_stream][dataset]" => "pfelk.unbound"
        "[data_stream][namespace]" => "unbound"
      }
    }
    
    # Parse DNSSEC validation messages
    if [filter_message] =~ /Verified that/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: Verified that %{WORD:[dnssec][response_type]} response is %{WORD:[dnssec][validation_state]}" ]
        tag_on_failure => ["grok_fail_35_unbound_dnssec_validation"]
      }
      mutate {
        add_field => { "[dnssec][message_type]" => "validation" }
        add_tag => "dnssec_validation"
      }
    }
    else if [filter_message] =~ /NSEC3?s? / {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: %{WORD:[dnssec][proof_type]} for %{DATA:[dnssec][target]} (?<[dnssec][result]>proved .+)$" ]
        tag_on_failure => ["grok_fail_35_unbound_dnssec_proof"]
      }
      mutate {
        add_field => { "[dnssec][message_type]" => "proof" }
        add_tag => "dnssec_proof"
      }
    }
    else if [filter_message] =~ /validation failure/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: validation failure %{NOTSPACE:[dns][question][name]}" ]
        tag_on_failure => ["grok_fail_35_unbound_dnssec_validation_failure"]
      }
      mutate {
        add_field => { 
          "[dnssec][message_type]" => "validation_failure"
          "[event][outcome]" => "failure"
        }
        add_tag => "dnssec_failure"
      }
    }
    else if [filter_message] =~ /prime trust anchor/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: %{DATA:[dnssec][action]}: %{GREEDYDATA:[dnssec][details]}" ]
        tag_on_failure => ["grok_fail_35_unbound_dnssec_trust_anchor"]
      }
      mutate {
        add_field => { "[dnssec][message_type]" => "trust_anchor" }
        add_tag => "dnssec_anchor"
      }
    }
    else if [filter_message] =~ /sendto failed/ {
      grok {
        match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: sendto failed: %{GREEDYDATA:[network][error]}" ]
        tag_on_failure => ["grok_fail_35_unbound_sendto_failed"]
      }
      mutate {
        add_field => { "[event][outcome]" => "failure" }
        add_tag => "network_error"
      }
    }
    # Parse actual DNS queries/responses
    else {
      # First, check for response status messages (e.g., "query response was nodata ANSWER")
      if [filter_message] =~ /query response was/ {
        grok {
          match => [ "filter_message", "\[%{INT:[process][pgid]}:%{INT:[process][thread][id]}\] %{LOGLEVEL:[log][level]}: query response was %{WORD:[dns][response_status]} %{WORD:[dns][response_type]}" ]
          tag_on_failure => ["grok_fail_35_unbound_query_response_status"]
        }
        mutate {
          add_field => { "[dns][message_type]" => "response_status" }
        }
      }
      # Otherwise, parse as normal DNS query/response
      else {
        grok {
          patterns_dir => [ "/etc/pfelk/patterns" ]
          match => [ "filter_message", "%{UNBOUND}" ]
          tag_on_failure => ["grok_fail_35_unbound_main"]
        }
        if "_grokparsefailure" in [tags] {
          mutate { remove_tag => [ "_grokparsefailure", "grok_fail_35_unbound_main" ] }
          grok {
            patterns_dir => [ "/etc/pfelk/patterns" ]
            match => [ "filter_message", "%{UNBOUND_RESOLVING}" ]
            tag_on_failure => ["grok_fail_35_unbound_resolving"]
          }
        }
        ### unbound ECS => Built-in SIEM ###
        grok {
          match => [ "[dns][question][name]", "(\.)?(?<[dns][question][registered_domain]>[^.]+\.[^.]+)\.?$" ] 
          add_tag => "unbound-registered_domain"
          tag_on_failure => ["grok_fail_35_unbound_registered_domain_first"]
        }
        if "unbound-registered_domain" not in [tags] {
          grok { 
            match => [ "[dns][question][name]", "(?<[dns][question][registered_domain]>[^.]+\.[^.]+)\.?$" ] 
            tag_on_failure => ["grok_fail_35_unbound_registered_domain_second"]
          }
        }
        grok {
          match => [ "[dns][question][name]", "(\.)?(?<[dns][question][top_level_domain]>[^.]+)\.?$" ]
          tag_on_failure => ["grok_fail_35_unbound_tld"]
        }

        mutate {
          remove_tag => "unbound-registered_domain"
        }
      
      # Ensure dataset is set even if earlier steps fail
      if "unbound" in [tags] {
        mutate { replace => { "[event][dataset]" => "pfelk.unbound" "[data_stream][dataset]" => "pfelk.unbound" } }
      }
      }
    }
  }
}
